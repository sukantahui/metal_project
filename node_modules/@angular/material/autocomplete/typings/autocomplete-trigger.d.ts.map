{"version":3,"file":"autocomplete-trigger.d.ts","sources":["autocomplete-trigger.d.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;AAqBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyIA","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directionality } from '@angular/cdk/bidi';\nimport { Overlay, RepositionScrollStrategy, ScrollStrategy } from '@angular/cdk/overlay';\nimport { ChangeDetectorRef, ElementRef, InjectionToken, NgZone, OnDestroy, ViewContainerRef } from '@angular/core';\nimport { ControlValueAccessor } from '@angular/forms';\nimport { MatOption, MatOptionSelectionChange } from '@angular/material/core';\nimport { MatFormField } from '@angular/material/form-field';\nimport { Observable } from 'rxjs/Observable';\nimport { MatAutocomplete } from './autocomplete';\n/**\n * The following style constants are necessary to save here in order\n * to properly calculate the scrollTop of the panel. Because we are not\n * actually focusing the active item, scroll must be handled manually.\n */\n/** The height of each autocomplete option. */\nexport declare const AUTOCOMPLETE_OPTION_HEIGHT = 48;\n/** The total height of the autocomplete panel. */\nexport declare const AUTOCOMPLETE_PANEL_HEIGHT = 256;\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\nexport declare const MAT_AUTOCOMPLETE_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;\n/** @docs-private */\nexport declare function MAT_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay: Overlay): () => RepositionScrollStrategy;\n/** @docs-private */\nexport declare const MAT_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER: {\n    provide: InjectionToken<() => ScrollStrategy>;\n    deps: typeof Overlay[];\n    useFactory: (overlay: Overlay) => () => RepositionScrollStrategy;\n};\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * @docs-private\n */\nexport declare const MAT_AUTOCOMPLETE_VALUE_ACCESSOR: any;\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n */\nexport declare function getMatAutocompleteMissingPanelError(): Error;\nexport declare class MatAutocompleteTrigger implements ControlValueAccessor, OnDestroy {\n    private _element;\n    private _overlay;\n    private _viewContainerRef;\n    private _zone;\n    private _changeDetectorRef;\n    private _scrollStrategy;\n    private _dir;\n    private _formField;\n    private _document;\n    private _overlayRef;\n    private _portal;\n    private _panelOpen;\n    /** Strategy that is used to position the panel. */\n    private _positionStrategy;\n    /** Whether or not the placeholder state is being overridden. */\n    private _manuallyFloatingPlaceholder;\n    /** The subscription for closing actions (some are bound to document). */\n    private _closingActionsSubscription;\n    /** Stream of escape keyboard events. */\n    private _escapeEventStream;\n    /** View -> model callback called when value changes */\n    _onChange: (value: any) => void;\n    /** View -> model callback called when autocomplete has been touched */\n    _onTouched: () => void;\n    autocomplete: MatAutocomplete;\n    constructor(_element: ElementRef, _overlay: Overlay, _viewContainerRef: ViewContainerRef, _zone: NgZone, _changeDetectorRef: ChangeDetectorRef, _scrollStrategy: any, _dir: Directionality, _formField: MatFormField, _document: any);\n    ngOnDestroy(): void;\n    readonly panelOpen: boolean;\n    /** Opens the autocomplete suggestion panel. */\n    openPanel(): void;\n    /** Closes the autocomplete suggestion panel. */\n    closePanel(): void;\n    /**\n     * A stream of actions that should close the autocomplete panel, including\n     * when an option is selected, on blur, and when TAB is pressed.\n     */\n    readonly panelClosingActions: Observable<MatOptionSelectionChange>;\n    /** Stream of autocomplete option selections. */\n    readonly optionSelections: Observable<MatOptionSelectionChange>;\n    /** The currently active option, coerced to MatOption type. */\n    readonly activeOption: MatOption | null;\n    /** Stream of clicks outside of the autocomplete panel. */\n    private readonly _outsideClickStream;\n    /**\n     * Sets the autocomplete's value. Part of the ControlValueAccessor interface\n     * required to integrate with Angular's core forms API.\n     *\n     * @param value New value to be written to the model.\n     */\n    writeValue(value: any): void;\n    /**\n     * Saves a callback function to be invoked when the autocomplete's value\n     * changes from user input. Part of the ControlValueAccessor interface\n     * required to integrate with Angular's core forms API.\n     *\n     * @param fn Callback to be triggered when the value changes.\n     */\n    registerOnChange(fn: (value: any) => {}): void;\n    /**\n     * Saves a callback function to be invoked when the autocomplete is blurred\n     * by the user. Part of the ControlValueAccessor interface required\n     * to integrate with Angular's core forms API.\n     *\n     * @param fn Callback to be triggered when the component has been touched.\n     */\n    registerOnTouched(fn: () => {}): void;\n    _handleKeydown(event: KeyboardEvent): void;\n    _handleInput(event: KeyboardEvent): void;\n    _handleFocus(): void;\n    /**\n     * In \"auto\" mode, the placeholder will animate down as soon as focus is lost.\n     * This causes the value to jump when selecting an option with the mouse.\n     * This method manually floats the placeholder until the panel can be closed.\n     * @param shouldAnimate Whether the placeholder should be animated when it is floated.\n     */\n    private _floatPlaceholder(shouldAnimate?);\n    /** If the placeholder has been manually elevated, return it to its normal state. */\n    private _resetPlaceholder();\n    /**\n     * Given that we are not actually focusing active options, we must manually adjust scroll\n     * to reveal options below the fold. First, we find the offset of the option from the top\n     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n     * the panel height + the option height, so the active option will be just visible at the\n     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n     * will become the offset. If that offset is visible within the panel already, the scrollTop is\n     * not adjusted.\n     */\n    private _scrollToOption();\n    /**\n     * This method listens to a stream of panel closing actions and resets the\n     * stream every time the option list changes.\n     */\n    private _subscribeToClosingActions();\n    /** Destroys the autocomplete suggestion panel. */\n    private _destroyPanel();\n    private _setTriggerValue(value);\n    /**\n    * This method closes the panel, and if a value is specified, also sets the associated\n    * control to that value. It will also mark the control as dirty if this interaction\n    * stemmed from the user.\n    */\n    private _setValueAndClose(event);\n    /**\n     * Clear any previous selected option and emit a selection change event for this option\n     */\n    private _clearPreviousSelectedOption(skip);\n    private _attachOverlay();\n    private _getOverlayConfig();\n    private _getOverlayPosition();\n    private _getConnectedElement();\n    /** Returns the width of the input element, so the panel width can match it. */\n    private _getHostWidth();\n    /** Reset active item to -1 so arrow events will activate the correct options.*/\n    private _resetActiveItem();\n}\n"]}