{"version":3,"file":"option.d.ts","sources":["option.d.ts"],"names":[],"mappings":"AAAA;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsFA","sourcesContent":["import { ChangeDetectorRef, ElementRef, EventEmitter, QueryList } from '@angular/core';\nimport { MatOptgroup } from './optgroup';\n/** Event object emitted by MatOption when selected or deselected. */\nexport declare class MatOptionSelectionChange {\n    source: MatOption;\n    isUserInput: boolean;\n    constructor(source: MatOption, isUserInput?: boolean);\n}\n/**\n * Single option inside of a `<mat-select>` element.\n */\nexport declare class MatOption {\n    private _element;\n    private _changeDetectorRef;\n    readonly group: MatOptgroup;\n    private _selected;\n    private _active;\n    private _multiple;\n    private _disableRipple;\n    /** Whether the option is disabled.  */\n    private _disabled;\n    private _id;\n    /** Whether the wrapping component is in multiple selection mode. */\n    multiple: boolean;\n    /** The unique ID of the option. */\n    readonly id: string;\n    /** Whether or not the option is currently selected. */\n    readonly selected: boolean;\n    /** The form value of the option. */\n    value: any;\n    /** Whether the option is disabled. */\n    disabled: any;\n    /** Whether ripples for the option are disabled. */\n    disableRipple: boolean;\n    /** Event emitted when the option is selected or deselected. */\n    onSelectionChange: EventEmitter<MatOptionSelectionChange>;\n    constructor(_element: ElementRef, _changeDetectorRef: ChangeDetectorRef, group: MatOptgroup);\n    /**\n     * Whether or not the option is currently active and ready to be selected.\n     * An active option displays styles as if it is focused, but the\n     * focus is actually retained somewhere else. This comes in handy\n     * for components like autocomplete where focus must remain on the input.\n     */\n    readonly active: boolean;\n    /**\n     * The displayed value of the option. It is necessary to show the selected option in the\n     * select's trigger.\n     */\n    readonly viewValue: string;\n    /** Selects the option. */\n    select(): void;\n    /** Deselects the option. */\n    deselect(): void;\n    /** Sets focus onto this option. */\n    focus(): void;\n    /**\n     * This method sets display styles on the option to make it appear\n     * active. This is used by the ActiveDescendantKeyManager so key\n     * events will display the proper options as active on arrow key events.\n     */\n    setActiveStyles(): void;\n    /**\n     * This method removes display styles on the option that made it appear\n     * active. This is used by the ActiveDescendantKeyManager so key\n     * events will display the proper options as active on arrow key events.\n     */\n    setInactiveStyles(): void;\n    /** Gets the label to be used when determining whether the option should be focused. */\n    getLabel(): string;\n    /** Ensures the option is selected when activated from the keyboard. */\n    _handleKeydown(event: KeyboardEvent): void;\n    /**\n     * Selects the option while indicating the selection came from the user. Used to\n     * determine if the select's view -> model callback should be invoked.\n     */\n    _selectViaInteraction(): void;\n    /** Returns the correct tabindex for the option depending on disabled state. */\n    _getTabIndex(): string;\n    /** Gets the host DOM element. */\n    _getHostElement(): HTMLElement;\n    /** Emits the selection change event. */\n    private _emitSelectionChangeEvent(isUserInput?);\n    /**\n     * Counts the amount of option group labels that precede the specified option.\n     * @param optionIndex Index of the option at which to start counting.\n     * @param options Flat list of all of the options.\n     * @param optionGroups Flat list of all of the option groups.\n     */\n    static countGroupLabelsBeforeOption(optionIndex: number, options: QueryList<MatOption>, optionGroups: QueryList<MatOptgroup>): number;\n}\n"]}