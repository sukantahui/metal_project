{"version":3,"file":"drawer.d.ts","sources":["drawer.d.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuEA","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { AnimationEvent } from '@angular/animations';\nimport { FocusTrapFactory } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { AfterContentInit, ChangeDetectorRef, ElementRef, EventEmitter, NgZone, OnDestroy, QueryList, Renderer2 } from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\n/** Throws an exception when two MatDrawer are matching the same position. */\nexport declare function throwMatDuplicatedDrawerError(position: string): void;\n/**\n * Drawer toggle promise result.\n * @deprecated\n */\nexport declare class MatDrawerToggleResult {\n    type: 'open' | 'close';\n    animationFinished: boolean;\n    constructor(type: 'open' | 'close', animationFinished: boolean);\n}\nexport declare class MatDrawerContent implements AfterContentInit {\n    private _changeDetectorRef;\n    private _container;\n    /**\n     * Margins to be applied to the content. These are used to push / shrink the drawer content when a\n     * drawer is open. We use margin rather than transform even for push mode because transform breaks\n     * fixed position elements inside of the transformed element.\n     */\n    _margins: {\n        left: number;\n        right: number;\n    };\n    constructor(_changeDetectorRef: ChangeDetectorRef, _container: MatDrawerContainer);\n    ngAfterContentInit(): void;\n}\n/**\n * This component corresponds to a drawer that can be opened on the drawer container.\n */\nexport declare class MatDrawer implements AfterContentInit, OnDestroy {\n    private _elementRef;\n    private _focusTrapFactory;\n    private _doc;\n    private _focusTrap;\n    private _elementFocusedBeforeDrawerWasOpened;\n    /** Whether the drawer is initialized. Used for disabling the initial animation. */\n    private _enableAnimations;\n    /** The side that the drawer is attached to. */\n    position: 'start' | 'end';\n    private _position;\n    /** @deprecated */\n    align: 'start' | 'end';\n    /** Mode of the drawer; one of 'over', 'push' or 'side'. */\n    mode: 'over' | 'push' | 'side';\n    private _mode;\n    /** Whether the drawer can be closed with the escape key or by clicking on the backdrop. */\n    disableClose: boolean;\n    private _disableClose;\n    /** Whether the drawer is opened. */\n    private _opened;\n    /** Emits whenever the drawer has started animating. */\n    _animationStarted: EventEmitter<AnimationEvent>;\n    /** Whether the drawer is animating. Used to prevent overlapping animations. */\n    _isAnimating: boolean;\n    /** Current state of the sidenav animation. */\n    _animationState: 'open-instant' | 'open' | 'void';\n    /**\n     * Promise that resolves when the open/close animation completes. It is here for backwards\n     * compatibility and should be removed next time we do drawer breaking changes.\n     * @deprecated\n     */\n    private _currentTogglePromise;\n    /** Event emitted when the drawer is fully opened. */\n    onOpen: EventEmitter<void | MatDrawerToggleResult>;\n    /** Event emitted when the drawer is fully closed. */\n    onClose: EventEmitter<void | MatDrawerToggleResult>;\n    /** Event emitted when the drawer's position changes. */\n    onPositionChanged: EventEmitter<void>;\n    /** @deprecated */\n    onAlignChanged: EventEmitter<void>;\n    /**\n     * An observable that emits when the drawer mode changes. This is used by the drawer container to\n     * to know when to when the mode changes so it can adapt the margins on the content.\n     */\n    _modeChanged: Subject<{}>;\n    readonly _isFocusTrapEnabled: boolean;\n    constructor(_elementRef: ElementRef, _focusTrapFactory: FocusTrapFactory, _doc: any);\n    /**\n     * If focus is currently inside the drawer, restores it to where it was before the drawer\n     * opened.\n     */\n    private _restoreFocus();\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    /**\n     * Whether the drawer is opened. We overload this because we trigger an event when it\n     * starts or end.\n     */\n    opened: boolean;\n    /** Open the drawer. */\n    open(): Promise<MatDrawerToggleResult>;\n    /** Close the drawer. */\n    close(): Promise<MatDrawerToggleResult>;\n    /**\n     * Toggle this drawer.\n     * @param isOpen Whether the drawer should be open.\n     */\n    toggle(isOpen?: boolean): Promise<MatDrawerToggleResult>;\n    /**\n     * Handles the keyboard events.\n     * @docs-private\n     */\n    handleKeydown(event: KeyboardEvent): void;\n    _onAnimationStart(event: AnimationEvent): void;\n    _onAnimationEnd(event: AnimationEvent): void;\n    readonly _width: any;\n}\n/**\n * <mat-drawer-container> component.\n *\n * This is the parent component to one or two <mat-drawer>s that validates the state internally\n * and coordinates the backdrop and content styling.\n */\nexport declare class MatDrawerContainer implements AfterContentInit, OnDestroy {\n    private _dir;\n    private _element;\n    private _renderer;\n    private _ngZone;\n    private _changeDetectorRef;\n    _drawers: QueryList<MatDrawer>;\n    _content: MatDrawerContent;\n    /** The drawer child with the `start` position. */\n    readonly start: MatDrawer | null;\n    /** The drawer child with the `end` position. */\n    readonly end: MatDrawer | null;\n    /** Event emitted when the drawer backdrop is clicked. */\n    backdropClick: EventEmitter<void>;\n    /** The drawer at the start/end position, independent of direction. */\n    private _start;\n    private _end;\n    /**\n     * The drawer at the left/right. When direction changes, these will change as well.\n     * They're used as aliases for the above to set the left/right style properly.\n     * In LTR, _left == _start and _right == _end.\n     * In RTL, _left == _end and _right == _start.\n     */\n    private _left;\n    private _right;\n    /** Emits when the component is destroyed. */\n    private _destroyed;\n    _contentMargins: Subject<{\n        left: number;\n        right: number;\n    }>;\n    constructor(_dir: Directionality, _element: ElementRef, _renderer: Renderer2, _ngZone: NgZone, _changeDetectorRef: ChangeDetectorRef);\n    ngAfterContentInit(): void;\n    ngOnDestroy(): void;\n    /** Calls `open` of both start and end drawers */\n    open(): void;\n    /** Calls `close` of both start and end drawers */\n    close(): void;\n    /**\n     * Subscribes to drawer events in order to set a class on the main container element when the\n     * drawer is open and the backdrop is visible. This ensures any overflow on the container element\n     * is properly hidden.\n     */\n    private _watchDrawerToggle(drawer);\n    /**\n     * Subscribes to drawer onPositionChanged event in order to\n     * re-validate drawers when the position changes.\n     */\n    private _watchDrawerPosition(drawer);\n    /** Subscribes to changes in drawer mode so we can run change detection. */\n    private _watchDrawerMode(drawer);\n    /** Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element. */\n    private _setContainerClass(isAdd);\n    /** Validate the state of the drawer children components. */\n    private _validateDrawers();\n    _onBackdropClicked(): void;\n    _closeModalDrawer(): void;\n    _isShowingBackdrop(): boolean;\n    private _isDrawerOpen(drawer);\n    /**\n     * Recalculates and updates the inline styles for the content. Note that this should be used\n     * sparingly, because it causes a reflow.\n     */\n    private _updateContentMargins();\n}\n"]}