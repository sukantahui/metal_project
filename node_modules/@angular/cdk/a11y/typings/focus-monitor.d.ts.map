{"version":3,"file":"focus-monitor.d.ts","sources":["focus-monitor.d.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsEA;;;;;;;;;;;;;;;;;;;AAiBA","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Platform } from '@angular/cdk/platform';\nimport { ElementRef, EventEmitter, NgZone, OnDestroy, Optional, Renderer2 } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nexport declare const TOUCH_BUFFER_MS = 650;\nexport declare type FocusOrigin = 'touch' | 'mouse' | 'keyboard' | 'program' | null;\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\nexport declare class FocusMonitor {\n    private _ngZone;\n    private _platform;\n    /** The focus origin that the next focus event is a result of. */\n    private _origin;\n    /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */\n    private _lastFocusOrigin;\n    /** Whether the window has just been focused. */\n    private _windowFocused;\n    /** The target of the last touch event. */\n    private _lastTouchTarget;\n    /** The timeout id of the touch timeout, used to cancel timeout later. */\n    private _touchTimeout;\n    /** Weak map of elements being monitored to their info. */\n    private _elementInfo;\n    constructor(_ngZone: NgZone, _platform: Platform);\n    /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param element The element to monitor\n     * @param renderer The renderer to use to apply CSS classes to the element.\n     * @param checkChildren Whether to count the element as focused when its children are focused.\n     * @returns An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    monitor(element: HTMLElement, renderer: Renderer2, checkChildren: boolean): Observable<FocusOrigin>;\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    stopMonitoring(element: HTMLElement): void;\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element The element to focus.\n     * @param origin The focus origin.\n     */\n    focusVia(element: HTMLElement, origin: FocusOrigin): void;\n    /** Register necessary event listeners on the document and window. */\n    private _registerDocumentEvents();\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param element The element to update the classes on.\n     * @param origin The focus origin.\n     */\n    private _setClasses(element, origin?);\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param origin The origin to set.\n     */\n    private _setOriginForCurrentEventQueue(origin);\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param event The focus event to check.\n     * @returns Whether the event was caused by a touch.\n     */\n    private _wasCausedByTouch(event);\n    /**\n     * Handles focus events on a registered element.\n     * @param event The focus event.\n     * @param element The monitored element.\n     */\n    private _onFocus(event, element);\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    _onBlur(event: FocusEvent, element: HTMLElement): void;\n}\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nexport declare class CdkMonitorFocus implements OnDestroy {\n    private _elementRef;\n    private _focusMonitor;\n    private _monitorSubscription;\n    cdkFocusChange: EventEmitter<FocusOrigin>;\n    constructor(_elementRef: ElementRef, _focusMonitor: FocusMonitor, renderer: Renderer2);\n    ngOnDestroy(): void;\n}\n/** @docs-private */\nexport declare function FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher: FocusMonitor, ngZone: NgZone, platform: Platform): FocusMonitor;\n/** @docs-private */\nexport declare const FOCUS_MONITOR_PROVIDER: {\n    provide: typeof FocusMonitor;\n    deps: (Optional[] | typeof Platform | typeof NgZone)[];\n    useFactory: (parentDispatcher: FocusMonitor, ngZone: NgZone, platform: Platform) => FocusMonitor;\n};\n"]}